# HotSpot 虚拟机对象

## 创建过程

![Java创建对象的过程](./images/Java创建对象的过程.png)

### Step 1：类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过

如果没有，那必须先执行相应的类加载过程

### Step 2：分配内存

在类加载检查通过后，接下来虚拟机将为新生对象**分配内存**

对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来

分配方式有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择何种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**

[更多有关GC](#GC)

#### 内存分配的2种方式

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整，而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的

![内存分配的两种方式](./images/内存分配的两种方式.png)

#### 内存分配并发问题

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全

+ **CAS+失败重试**：CAS 是乐观锁的一种实现方式，所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止，虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性
+ **TLAB**：为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

[更多有关TLAB](#TLAB)

### Step 3：初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值

### Step 4：设置对象头

初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息，这些信息存放在对象头中

根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式

### Step 5：执行 init 方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始， `init` 方法还没有执行，所有的字段都还为零

一般来说，执行 new 指令之后会接着执行 `init` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来

## 对象的内存布局

在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**

Hotspot 虚拟机的**对象头**包括两部分信息，第一部分用于存储**对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等）**，另一部分是**类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例

**实例数据**部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容

**对齐填充**部分不是必然存在的，也没有什么特别的含义，**仅仅起占位作用**，因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍，而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全

## 对象的访问定位

建立对象就是为了使用对象， Java 程序通过栈上的 reference 数据来操作堆上的具体对象

对象的访问方式由虚拟机实现而定，目前主流的访问方式有**使用句柄**和**直接指针**两种

1. **句柄**：如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，**使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改**
2. **直接指针**：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址，**使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销**

![对象的访问定位-直接指针](./images/对象的访问定位-直接指针.png)

## GC

Java 常见的垃圾收集器

+ Serial GC
  + 优点：单线程精简的GC实现，无需维护复杂的数据结构，初始化简单，是client模式下JVM默认选项，最古老的GC
  + 缺点：会进入"Stop-The-World"状态
+ ParNew GC
  + 新生代GC实现，是SerialGC的多线程版本，最常见的应用场景是配合老年代的CMS GC 工作
+ CMS（Concurrent Mark Sweep）GC
  + 优点：基于标记-清除（Mark-Sweep）算法，尽量减少停顿时间
  + 缺点：存在碎片化问题，在长时间运行的情况下会发生full GC，导致恶劣停顿，会占用更多的CPU资源，和用户争抢线程，在JDK 9中被标记为废弃
+ Parrallel GC
  + 在JDK8等版本中，是server模式JVM的默认GC选择，也被称为吞吐量优先的GC，算法和Serial GC相似，特点是老生代和新生代GC并行进行，更加高效
+ G1 GC
  + 兼顾了吞吐量和停顿时间的GC实现，是Oracle JDK 9后默认的GC
  + 可以直观的设值停顿时间，相对于CMS GC ，G1未必能做到CMS最好情况下的延时停顿，但比最差情况要好得多
  + G1 仍存在年代的概念，使用了Region棋盘算法，实际上是标记-整理（Mark-Compact）算法，可以避免内存碎片，尤其是堆非常大的时候，G1优势更明显
  + G1 吞吐量和停顿表现都非常不错

## TLAB

TLAB的全称是Thread Local Allocation Buffer，即线程本地分配缓存区，这是**一个线程专用的内存分配区域**

如果设置了虚拟机参数 `-XX:UseTLAB`，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率

TLAB空间的内存非常小，缺省情况下仅占有整个Eden空间的1%，也可以通过选项`-XX:TLABWasteTargetPercent`设置TLAB空间所占用Eden空间的百分比大小

TLAB的本质其实是三个指针管理的区域：start，top 和 end，每个线程都会从Eden分配一块空间，例如说100KB，作为自己的TLAB，其中 start 和 end 是占位用的，标识出 eden 里被这个 TLAB 所管理的区域，卡住eden里的一块空间不让其它线程来这里分配

TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配

当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB，而在老TLAB里的对象还留在原地什么都不用管——它们无法感知自己是否是曾经从TLAB分配出来的，而只关心自己是在eden里分配的

TLAB 的缺陷：

+ TLAB通常很小，所以放不下大对象
+ TLAB的空间大概率出现浪费

在创建对象时 JVM 做了以下处理：

+ 当剩余的空间小于最大浪费空间，该TLAB属于的线程重新向Eden区申请一个TLAB空间，如果空间仍然不够，则在Eden区直接创建
+ 当剩余的空间大于最大浪费空间，直接在Eden区创建
