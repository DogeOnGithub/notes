# 缓存数据库数据一致性问题

一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果系统**不是严格要求** “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：**读请求和写请求串行化**，串到一个**内存队列**里去

串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求

## 目前存在的4种缓存与数据库双写策略

1. 先更新缓存，再更新数据库
2. 先更新数据库，再更新缓存
3. 先删除缓存，再更新数据库
4. 先更新数据库，再删除缓存

## 先更新缓存，再更新数据库

数据应以数据库为准，优先保证数据库数据的准确性，缓存只需要尽力保证即可
先更新缓存，再更新数据库，如果缓存更新成功，数据库更新失败，则数据不一致，且丢失的数据不会再回到数据库中了
因此，该方案优先被抛弃，不予考虑

## 先更新数据库，再更新缓存

### 高并发场景容易出现脏数据

同时有请求A和请求B进行更新操作，那么会出现：

1. 线程A更新了数据库
2. 线程B更新了数据库
3. 线程B更新了缓存
4. 线程A更新了缓存

正常情况，A请求先进入，应该是先更新数据库，并先更新缓存，但由于网络等原因，导致A更新了数据库后，并没有能立即更新缓存，而是在B更新了数据库和缓存后才成功缓存，此时，数据库中是B更新的数据，而缓存中却是A的数据库，这时便是脏数据

### 业务场景考虑

1. 如果是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能
2. 如果写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存，那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的，显然，删除缓存更为适合

### 该方案不予考虑

## 先删除缓存，再更新数据库

高并发场景下，该策略可能会出现以下情况：

1. 请求A进行写操作，删除缓存
2. 请求B查询发现缓存不存在
3. 请求B去数据库查询得到旧值
4. 请求B将旧值写入缓存
5. 请求A将新值写入数据库

该情况会导致缓存中的数据并不是数据库的最新数据，数据不一致
在缓存不设置过期时间时，缓存中的脏数据会持续

### 此时可以使用 `延时双删` 策略

具体策略步骤如下：

1. 先淘汰缓存
2. 再写数据库（这两步和原来一样）
3. 休眠1秒，再次淘汰缓存

休眠1秒并不是绝对的，需要根据具体场景来确定，一般在读业务的耗时上增加几百ms即可，如果是数据库主从分离的，则需要加上主从同步的时间

可以考虑将第3步（第二次淘汰缓存）设为异步，以避免线程休眠导致吞吐量下降

但是仍然有可能会产生脏数据（第2次淘汰缓存失败时）：

1. 请求A删除缓存
2. 请求B查询，未命中缓存
3. 请求B查询数据库得到旧值，并将旧值写入缓存
4. 请求A写入数据库
5. 请求A删除缓存失败，此时缓存中是请求B存入的旧值，数据不一致

此时可以参考 `Cache Aside Pattern` 策略

## Cache Aside Pattern

最经典的缓存+数据库读写的模式，就是 `Cache Aside Pattern`

+ 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应
+ 更新的时候，**先更新数据库，然后再删除缓存**

`先更新数据库，再删除缓存策略`可能会出现数据不一致的情况：

1. 缓存刚好失效
2. 请求A查询数据库，得一个旧值
3. 请求B将新值写入数据库
4. 请求B删除缓存
5. 请求A将查到的旧值写入缓存

虽然上述情况会导致数据不一致，但却有一个先决条件：数据库的读操作比写操作慢
当2步骤比3步骤慢时，4步骤才会走在5步骤前面，即读操作比写操作耗时更长，但实际上这种事情发生的概率很小
