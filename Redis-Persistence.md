# Redis Persistence

## Redis 的2种持久化方式

+ **RDB**：RDB 持久化机制，是对 Redis 中的数据执行**周期性**的持久化
+ **AOF**：AOF 机制对每条写入命令作为日志，以 `append-only` 的模式写入一个日志文件中，在 Redis 重启的时候，可以通过**回放** AOF 日志中的写入指令来重新构建整个数据集

通过 RDB 或 AOF，都可以将 Redis 内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云等云服务

如果 Redis 挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动 Redis，Redis 就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务

如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 **AOF** 来重新构建数据，因为 AOF 中的**数据更加完整**

### RDB

RDB 可以使用 **同步阻塞的 save**（执行同步的RDB操作时，redis是不能对外提供服务的） ，以及 **非阻塞的 bgsave** ，bgsave 的原理是 **fork() + copyonwrite**

+ RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 Redis 的数据，这种多个数据文件的方式，**非常适合做冷备**，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 Redis 中的数据
+ RDB 对 Redis 对外提供的读写服务，影响非常小，可以让 Redis **保持高性能**，因为 Redis 主进程只需要 **`fork` 一个子进程**，让**子进程执行磁盘 IO 操作来进行 RDB 持久化**即可
+ 相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 Redis 进程，更加快速

+ RDB 做数据冷备时，一旦 Redis 宕机，可能会比 AOF 丢失更多的数据
+ 一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候一旦 Redis 进程宕机，那么会丢失最近 5 分钟的数据
+ RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒
  + fork会拷贝父进程的所有状态，包括已分配的内存
  + fork()是Unix操作系统的API，用于创建一个子进程
  + fork()出来的进程共享其父类的内存数据，仅仅是共享fork()出子进程的那一刻的内存数据，后期主进程修改数据对子进程不可见，同理，子进程修改的数据对主进程也不可见
  + 在不开启 copy-on-write 时，子进程并不是和父进程共享内存，使用Linux操作系统可以开启copy-on-write，子进程和父进程共享内存空间，但修改操作互不影响
  + 主进程fork()子进程之后，内核把主进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向主进程，也就是共享了主进程的内存
  + 当其中某个进程写内存时(这里肯定是主进程写，因为子进程只负责rdb文件持久化工作，不参与客户端的请求)，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入内核的一个中断例程
  + 中断例程中，内核就会把触发的异常的页复制一份（这里仅仅复制异常页，也就是所修改的那个数据页，而不是内存中的全部数据），于是主子进程各自持有独立的一份

### AOF

+ AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次 `fsync` 操作，最多丢失 1 秒钟的数据
+ AOF 日志文件以 `append-only` 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复
+ AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写，因为在 `rewrite` log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来，在创建新日志文件的时候，老的日志文件还是照常写入，当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可
+ AOF 日志文件的命令通过可读较强的方式进行记录，这个特性非常**适合做灾难性的误删除的紧急恢复**，比如某人不小心用 `flushall` 命令清空了所有数据，只要这个时候后台 `rewrite` 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 `flushall` 命令给删了，然后再将该 `AOF` 文件放回去，就可以通过恢复机制，自动恢复所有数据
+ 对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大
+ AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 `fsync` 一次日志文件，当然，每秒一次 `fsync` ，性能也还是很高的（如果实时写入，那么 QPS 会大降，Redis 性能会大大降低）
+ 以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来，所以说，类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug，不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是**基于当时内存中的数据进行指令的重新构建**，这样健壮性会好很多
  + rewrite会在AOF文件膨胀到一定程度时执行
  + rewrite会在从节点进行全量同步完成时立即执行

## RDB 和 AOF 到底该如何选择

+ 不要仅仅使用 RDB，因为那样会导致丢失很多数据
+ 也不要仅仅使用 AOF，因为那样有两个问题：
  + 通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快
  + RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug
+ Redis 支持同时开启开启两种持久化方式，可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择；用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复
