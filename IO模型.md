# IO模型

当前有5种IOS模型，分别为：阻塞IO（BIO），非阻塞IO（NIO），信号驱动IO，IO多路转接，异步IO（AIO）

在网络通信中，对数据进行读写的过程中，数据在发送端和接收端的相应设备上进行如下传递：
发送端发送缓冲区 -> 发送端驱动程序 -> 发送端网卡 -> 接收端网卡 -> 接收端驱动程序 -> 接收端接收缓冲区

对数据进行写入时，应用程序调用write/sendto等相关系统调用将数据发送到接收端的接收缓冲区
在读取数据时，应用程序调用read/recvfrom等相关系统调用将数据从接收缓冲区搬运到用户区

以数据的读取为例，在调用read等系统调用时，会经历以下两个阶段：
1. 等待数据到达内核接收缓冲区
2. 将数据从接收缓冲区搬运到用户区

## 阻塞IO（BIO）

阻塞式IO在进行数据读取时，如果**内核中没有数据**（发送端可能还没有发送数据或者发送的数据还没有达到），此时**内核就开始等待数据**，同时**用户进程也进入阻塞状态**，整个进程就会被挂起等待，不能做其他的事情
当有数据到达内核时，内核等待结束，将数据从内核拷贝到用户区，用户进程结束阻塞，从挂起状态转为运行状态

一般为调用```revform```系统调用进行数据读取，调用该系统调用后，线程将由用户态陷入到内核态（注意：用户态与内核态的切换将会产生额外的花销），并等待数据，数据到达后，线程再返回到用户态，数据也由缓冲区拷贝到用户区

**在Linux中，默认所有的socket都是阻塞式的**
阻塞式接口是指当进行系统调用时，如果数据没有准备好，该应用进程就会被挂起，系统调用不会返回，直到有数据达到或者调用出错时，系统调用才会返回，进程才会结束阻塞状态

**实际上几乎所有的IO接口（包含socket）都是阻塞的**

在网络编程中，一个服务器需要处理多客户端的情形，如果是单进程的服务器，在与一个客户端连接建立之后，服务器就会使用read等系统调用对客户端进行数据读取来处理请求，当该客户端没有发送数据或者发送的数据还没有达到时，服务器就会进入阻塞状态，此时整个服务器进程就会挂起，当其他客户端连接请求达到时，服务器由于处于挂起状态爱，什么也不能做，所以也不能对其他客户端进行处理，因此，上述所说的单进程的阻塞式IO的服务器只能处理一个客户端的情况，所以这样的服务器没有任何的实用性
可以创建多进程或多线程（多个执行流）来处理多客户端的情形，如果在对一个客户端进行读取时导致一个进程被挂起，可以创建其他的进程来处理其他客户端的请求，但是多进程和多线程的创建也要浪费一定的资源，也有一定的局限性，所以一般适用于中小型应用场景

## 非阻塞IO（NIO）

**在Linux中默认所有的套接字都是阻塞的，可以通过特定的系统调用来实现非阻塞的文件描述符**

非阻塞式IO在使用**recvfrom**等系统调用进行数据读取时，如果内核中没有数据到达，此时**内核会进行等待**，但是与阻塞式IO不同的是，此时的**用户进程并不会被阻塞，不会被挂起**，而是**出错返回**（此时相关系统调用的返回值为**-1**，并且errno被设置为**EAGAIN**，注意与recvfrom调用出错的区别，如果是函数调用出错，返回值也是-1，但是errno不是EAGAIN），出错返回之后进程可以做其他的事情
之后内核将数据准备好之后，由于该系统调用已经返回，所以进程无法得到数据已经准备好并且无法将数据由内核拷贝到用户区，所以，此时还需要使用系统调用进行数据的拷贝
因为不知道内核什么时候将数据准备好，所以就需要不断的使用系统调用来询问内核有没有将数据准备好（**不断进行轮询**），一旦准备好就进行数据的拷贝

**非阻塞式IO中，一般需要循环的对文件描述符进行读写，不断的询问数据有没有准备好，这个过程就称为轮询**
**在非阻塞IO中，内核在等待数据，用户进程在轮询访问数据有无准备好**

在该模型中，进程大部分的工作都是在轮询访问，被没有发挥实际有效的作用，所以这样做实际是对CPU资源的一种浪费，且不断的进行用户态和内核态的切换会产生额外开销，一般在特定场景下才会使用该模型

## 信号驱动IO

信号驱动IO中，当内核将数据准备好时，不是由进程调用read等系统调用来查看就绪条件是否满足，而是**通过各进程发送SIGIO信号通知应用进程数据**已经准备好，此时应用进程就可以调用read等来进行数据的读取

应用进程首先使用系统调用```sigaction```来建立SIGIO信号处理程序，然后该系统调用返回，内核进行数据的等待，此时用户应用进程可以做其他的事情，当内核中有数据到达时，操作系统会向进程发送SIGIO信号给应用进程，该信号被捕捉，此时应用进程便知道内核中有数据达到，所以在信号捕捉处理程序中调用read等系统调用进行数据的读取，将数据从内核拷贝到用户区。（注意，此时的文件描述符是阻塞式的）

信号驱动IO和非阻塞IO：
+ 区别：就绪条件满足时的通知方式不同，信号驱动IO是通过信号来告知，非阻塞式IO要循环使用系统调用进行轮询查看
+ 相同：二者在数据读取时都不会阻塞进程（信号驱动IO不阻塞是因为read时一定有数据，非阻塞IO不阻塞是因为没有数据时会直接出错返回），并且二者都需要主动使用read等系统调用进行数据的拷贝

## IO多路转接（IO多路复用）

**IO多路转接与上述三种方式最大的不同在于它一次等待多个文件描述符，并且它将等待和数据的拷贝分隔开**

在该方式下，应用进程首先使用select/epoll等系统调用等待多个文件描述符
**select等系统调用可以设置阻塞和非阻塞（或者阻塞的时间）**
如果是**阻塞方式**，若等待的所有文件描述符的数据均未达到，此时进程会阻塞在select处，当至少有一个文件描述符就绪条件满足时，该系统调用就会返回（这里与阻塞方式的read非常类似，只是read还有进行数据拷贝，select只是进行等待，返回时将满足就绪条件的文件描述符返回，并不进行数据的拷贝），此时应用进程再调用read等分别对就绪的文件描述符进行数据的拷贝
如果是**非阻塞方式或者设置了阻塞的时间**，当没有调用select时或者在规定时间内没有文件描述符满足就绪条件，此时select会出错返回-1，此时为了对数据进行操作，所以必须循环的调用select来判断有无文件描述符满足就绪条件（这里与非阻塞方式的read类似，不过与上述类似，select只负责等待，不负责拷贝）

当等待的多个文件描述符中至少有一个满足就绪条件时，select返回，此时应用进程调用read（此时的套接字是阻塞的）等对数据进行拷贝，此时，read一定不会阻塞，因为内核中一定有数据到达

如果在网络编程中，服务器采用的是IO多路转接的方式进行IO，当服务器分别将多个客户端的数据请求读取处理之后，有可能客户端还会就绪发送数据请求，所以服务器还需要在使用select来判断多个文件描述符上是否还有数据到达，因此，服务器必须循环的调用select等来不断的查看等待的文件描述符上是否有数据到达，然后进行不断地处理

 信号驱动IO和IO多路转接：
 + 相同：就绪条件满足时，都不是自己去探测的，同时，都是主动调用read等进行数据拷贝
 + 区别：信号驱动IO通过信号告知就绪条件满足，IO多路转接通过系统调用的返回值判断就绪条件是否满足，信号驱动IO一次只等待一个文件描述符，IO多路转接一次处理多个文件描述符

## 异步IO（AIO）

异步IO，应用进程提供一片缓冲区，使用特殊的系统调用```aio_read```，内核没有将数据准备好时，该系统调用直接返回，进程继续做其他的事情，此时内核等待数据，在数据到达后，将数据拷贝到用户空间完成后，再递交在aio_read中指定的信号，然后在对该信号进行捕捉时对数据进行处理，可以简单的理解为```callback```

该方式与上述几种方式不同点在于，进程使用的系统调用既**没有进行数据的等待**，又**没有进行数据的拷贝**
在数据拷贝完成之后通知应用进程，然后应用进程在进行处理

注意与**信号驱动IO**的区别：信号驱动IO是在数据准备好之后通知应用进程调用相关的函数进行数据的拷贝，而该方式是在数据拷贝完成之后通知应用进程直接对数据进行处理
