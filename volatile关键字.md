# volatile关键字

---

[参考链接：Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)

关于为什么在多线程的情况下需要保持数据的 ***`原子性`*** 、 ***`可见性`*** 、 ***`有序性`*** 可以参考上方链接

---

## 简单理解一下

+ ***原子性*** ：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行
假若一个线程对一个32位变量进行赋值，假设该步骤分为为低16位赋值，为高16位赋值，那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据

+ ***可见性*** ：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值
这种情况的出现和CPU、高速缓存、内存的关系有关，线程执行时，会先将数据从内存中加载到高速缓存中再执行代码，举个栗子：

    ```java
    // 线程1执行的代码
    int i = 0;
    i = 10;

    // 线程2执行的代码
    j = i;
    ```

    假若执行线程1的是CPU1，执行线程2的是CPU2，由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中，此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10

+ ***有序性*** ：即程序执行的顺序按照代码的先后顺序执行
一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的
`要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同`
`指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性`

+ ***`要想并发程序正确地执行，必须要保证原子性、可见性以及有序性`***

---

## Java内存模型

`在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果`

`JMM定义了程序中变量的访问规则（往大一点说是定义了程序执行的次序）`
`为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序，也就是说，***在java内存模型中，也会存在缓存一致性问题和指令重排序的问题`***

+ ***Java对于原子性的处理*** ：Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现

+ ***Java对于可见性的处理*** ：对于可见性，Java提供了volatile关键字来保证可见性
当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值
而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性
通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中，因此可以保证可见性

+ ***Java对于有序性的处理*** ：在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性
`在Java里面，可以通过volatile关键字来保证一定的“有序性”`
可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性
***`Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则，如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序`***

`***happens-before原则（先行发生原则）***` ：

+ `程序次序规则`：***一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作***（一段程序代码的执行在单个线程中看起来是有序的，`注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该 ***是程序看起来*** 执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序`，虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序，`这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性`）
+ `锁定规则`：***一个unLock操作先行发生于后面对同一个锁的lock操作***（也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作）
+ `volatile变量规则`：***对一个变量的写操作先行发生于后面对这个变量的读操作***（直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作）
+ `传递规则`：***如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C***（实际上就是体现happens-before原则具备传递性）
+ 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
+ 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
+ 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
+ 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

## 深入volatile关键字

1. **volatile关键字的两层语义**
一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
    1） 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的
    2） 禁止进行指令重排序
先看一段代码，假如线程1先执行，线程2后执行：

    ```java
    // 线程1
    boolean stop = false;
    while(!stop){
        doSomething();
    }

    // 线程2
    stop = true;
    ```

    当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去
    此时使用volatile关键字则可以保证线程1的停止：
    1. 使用volatile关键字会强制将修改的值立即写入主存
    2. 使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）
    3. 由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取

2. ***volatile关键字是否保证原子性***
先看例子：

    ```java
    public class Test {
        public volatile int inc = 0;

        public void increase() {
            inc++;
        }

        public static void main(String[] args) {
            final Test test = new Test();
            for(int i=0;i<10;i++){
                new Thread(){
                    public void run() {
                        for(int j=0;j<1000;j++)
                            test.increase();
                    };
                }.start();
            }

            while(Thread.activeCount()>1)  //保证前面的线程都执行完
                Thread.yield();
            System.out.println(test.inc);
        }
    }
    ```

    上面的代码并不会如愿的输出10000，事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字
    volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性
    `自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存`
    那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：
    1. 假如某个时刻变量inc的值为10
    2. 线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了
    3. 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存
    4. 然后线程1接着进行加1操作，由于已经读inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存
    5. 那么两个线程分别进行了一次自增操作后，inc只增加了1

3. ***volatile是否可以保证有序性***
volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性
volatile关键字禁止指令重排序有两层意思：
   1） 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行
   2） 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行

4. ***volatile的原理和实现机制***
下面这段话摘自《深入理解Java虚拟机》：
“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”
lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
   1） 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成
   2） 它会强制将对缓存的修改操作立即写入主存
   3） 如果是写操作，它会导致其他CPU中对应的缓存行无效
