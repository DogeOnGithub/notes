# 数据库连接池

---

[参考链接：数据库连接池的工作原理](https://www.cnblogs.com/shoshana-kong/p/11248972.html)

[参考链接：数据库连接池的工作机制是什么](https://www.cnblogs.com/mark5/p/11641046.html)

[参考链接：转载：数据库连接池到底应该设置多大?](https://www.cnblogs.com/qianjinyan/p/9327947.html)

[参考链接：数据库连接池的大小你真的设置对了吗](https://blog.csdn.net/ljheee/article/details/99127126)

[参考链接：HikariCP重要参数配置](https://www.cnblogs.com/fireround/p/11701369.html)

[参考链接：数据库连接池 HikariCP 使用实例及配置参数详解](https://blog.csdn.net/ssxueyi/article/details/83505322)

---

## 数据库连接池基本原理

`连接池技术的核心思想是连接复用，通过建立一个数据库连接池以及一套连接使用、分配和管理策略，使得该连接池中的连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销`

数据库连接是一种关键的有限的昂贵的资源，这一点企业级应用程序中体现得尤为突出
对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标

数据库连接池负责`分配、管理和释放数据库连接`，它`允许应用程序重复使用一个现有的数据库连接`，而再不是重新建立一个
释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接泄露

对于共享资源，有一个很著名的`设计模式：资源池（Resource Pool）`，该模式正是为了解决资源的频繁分配﹑释放所造成的问题
数据库连接池的基本思想就是`为数据库连接建立一个“缓冲池”`，预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去

数据库连接池`在初始化时将创建一定数量的数据库连接放到连接池中`，这些数据库连接的数量是由最小数据库连接数来设定的，无论这些数据库连接是否被使用，`连接池都将一直保证至少拥有这么多的连接数量`，连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，`当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中`

## 数据库连接池需要解决的关键问题

### 并发问题

为了使连接管理服务具有最大的通用性，必须考虑多线程环境，即并发问题
各个语言自身提供了对并发管理的支持像java，c#等等，`使用synchronized(java)、lock(C#)关键字即可确保线程是同步的`

### 事务处理

事务具有原子性，此时要求对数据库的操作符合“ALL-ALL-NOTHING”原则，即对于一组SQL语句要么全做，要么全不做
当２个线程公用一个连接Connection对象，而且各自都有自己的事务要处理时候，对于连接池是一个很头疼的问题，因为即使Connection类提供了相应的事务支持，可是仍然不能确定那个数据库操作是对应那个事务的，这是由于有２个线程都在进行事务操作而引起的
为此`可以使用每一个事务独占一个连接来实现`，虽然这种方法有点浪费连接池资源但是可以大大降低事务管理的复杂性

### 连接池的分配与释放

连接池的分配与释放，对系统的性能有很大的影响，合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度
此处可以使用引用计数的方法来对连接池的分配进行管理：

+ 分配、释放策略对于有效复用连接非常重要，采用的方法也是采用了一个很有名的设计模式：Reference Counting（引用记数）
+ 该模式在复用资源方面用的非常广泛，可以把该方法运用到对于连接的分配释放上
+ 每一个数据库连接，保留一个引用记数，用来记录该连接的使用者的个数
+ 具体的实现上，对Connection类进行进一步包装来实现引用记数，被包装的Connection类我们提供２个方法来实现引用记数的操作，一个是Repeat（被分配出去），Remove（被释放回来）；然后利用RepeatNow属性来确定当前被引用多少，具体是哪个用户引用了该连接将在连接池中登记；最后提供IsRepeat属性来确定该连接是否可以使用引用记数技术，`一旦一个连接被分配出去，那么就会对该连接的申请者进行登记，并且增加引用记数，当被释放回来时候就删除已经登记的信息，同时减少一次引用记数`

### 连接池的配置与维护

系统可采取设置`最小连接数（minConnection）`和`最大连接数（maxConnection）`等参数来控制连接池中的连接
比方说，最小连接数是系统启动时连接池所创建的连接数。如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢，可以在开发时，设置较小的最小连接数，开发起来会快，而在系统实际使用时设置较大的，因为这样对访问客户来说速度会快些

`最大连接数是连接池中允许连接的最大数目`，具体设置多少，要看系统的访问量，可通过软件需求上得到
`确保连接池的最小连接数有动态和静态两种策略`，`动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接，以保证连接池的正常运转`；`静态是发现空闲连接不够时再去检查`

## 数据库连接池连接数大小设置的问题

`连接数 = ((核心数 * 2) + 有效磁盘数)`

以上公式由PostgreSQL提供，但可以认为广泛地应用于大多数数据库产品
在确定应用的数据库连接池大小时，应该模拟预期的访问量，并从这一公式开始测试应用，寻找最合适的连接数值

`核心数不应包含超线程(hyper thread)，即使打开了hyperthreading也是`，`如果活跃数据全部被缓存了，那么有效磁盘数是0，随着缓存命中率的下降，有效磁盘数逐渐趋近于实际的磁盘数`，这一公式作用于SSD时的效果如何尚未有分析

此处与计算机原理有关，`一个CPU核心的在同一时间只能运行一个线程`，线程的并行是通过时间片轮换来完成的，线程的切换需要进行上下文切换而耗费时间
给定一颗CPU核心，其顺序执行A和B永远比通过时间分片“同时”执行A和B要快，这是一条计算机科学的基本法则，一旦线程的数量超过了CPU核心的数量，再增加线程数系统就只会更慢，而不是更快

寻找数据库的性能瓶颈时，总是可以将其归为三类：`CPU`、`磁盘`、`网络`
在磁盘、网络的影响下，连接数的设置会变得复杂，需要通过不断的测试来寻找最佳值

如果无视磁盘和网络，那么结论就非常简单，在一个8核的服务器上，设定连接/线程数为8能够提供最优的性能，再增加连接数就会因上下文切换的损耗导致性能下降，数据库通常把数据存储在磁盘上，磁盘又通常是由一些旋转着的金属碟片和一个装在步进马达上的读写头组成的，读/写头同一时刻只能出现在一个地方，然后它必须“寻址”到另外一个位置来执行另一次读写操作，所以就有了寻址的耗时，此外还有旋回耗时，读写头需要等待碟片上的目标数据“旋转到位”才能进行操作，使用缓存当然是能够提升性能的，但上述原理仍然成立

这一时间段（即"I/O等待"）内，线程是在“阻塞”着等待磁盘，此时操作系统可以将那个空闲的CPU核心用于服务其他线程，所以，由于线程总是在I/O上阻塞，可以让线程/连接数比CPU核心多一些，这样能够在同样的时间内完成更多的工作

较新型的SSD不需要寻址，也没有旋转的碟片，可别想当然地认为“SSD速度更快，所以应该增加线程数”，恰恰相反，无需寻址和没有旋回耗时意味着更少的阻塞，所以更少的线程[更接近于CPU核心数]会发挥出更高的性能，只有当阻塞创造了更多的执行机会时，更多的线程数才能发挥出更好的性能

网络是最后一个需要考虑的点

`最佳的数据库连接池连接数仍然需要通过实际场景来决定`

## HikariCP

HikariCP是SpringBoot的默认数据库连接池

当HikariCP初始化时候，会将添加连接到池中，`直到达到 minimum-idle 的数量`，此时保持这个状态
`当有新的连接池请求时，HikariCP会返回一个connection的代理，当connection都处于使用状态时，若此时有新的连接池请求，HikariCP就会继续新建connection直到达到 maximun-pool-size`

+ maximum-pool-size
  + 池中最大连接数（包括空闲和正在使用的连接）
  + 默认值是10，这个一般预估应用的最大连接数，后期根据监测得到一个最大值的一个平均值
  + 最大连接并不是越多越好，一个connection会占用系统的带宽和存储
  + 当连接池没有空闲连接并且已经到达最大值，新来的连接池请求（HikariPool#getConnection）会被阻塞直到`connectionTimeout`（毫秒），超时后便抛出SQLException

+ minimum-idle
  + 池中最小空闲连接数量
  + 默认值10，小于池中最大连接数，一般根据系统大部分情况下的数据库连接情况取一个平均值
  + Hikari会尽可能、尽快地将空闲连接数维持在这个数量上
  + 如果为了获得最佳性能和对峰值需求的响应能力，也不妨让其最大连接数保持一致，使得HikariCP成为一个固定大小的数据库连接池

+ pool-name
  + 连接池的名字
  + 一般会出现在日志和JMX控制台中

+ auto-commit
  + 是否自动提交池中返回的连接
  + 默认值为true，一般是有必要自动提交上一个连接中的事务
  + 如果为false，那么就需要应用层手动提交事务

+ idle-timeout
  + 空闲时间
  + `仅在minimum-idle小于maximum-poop-size的时候才会起作用`
  + 默认值10分钟
  + 根据应用实际情况做调整，对于一些间歇性流量达到峰值的应用，一般需要考虑设置的比间歇时间更大，防止创建数据库连接拖慢了应用速度

+ max-lifetime
  + 连接池中连接的最大生命周期
  + 当连接一直处于闲置状态时，数据库可能会主动断开连接，为了防止大量的同一时间处于空闲连接因为数据库方的闲置超时策略断开连接（可以理解为连接雪崩），一般将这个值设置的比数据库的“闲置超时时间”小几秒，以便这些连接断开后，HikariCP能迅速的创建新一轮的连接

+ connection-timeout
  + 连接超时时间
  + 默认值为30s，可以接收的最小超时时间为250ms
  + 连接池请求也可以自定义超时时间（com.zaxxer.hikari.pool.HikariPool#getConnection(long)）
